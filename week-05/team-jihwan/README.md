# TEAM 지환 - 5주차 RBF

## 라우팅이란

라우팅은 네트워크에서 경로를 선택하는 프로세스, 네트워크에서는 노드라고 하는 여러 시스템과 이러한 노드를 연결하는 경로 또는 링크로 구성된다. 상호 연결된 네트워크에서 두 노드 간의 통신은 여러 경로를 통해 이루어질 수 있다.

**라우팅은 미리 정해진 규칙을 사용하여 최상의 경로를 선택하는 프로세스이다.**

### 라우팅이 중요한 이유

라우팅은 네트워크 통신의 효율성을 높인다. 네트워크 통신 장애가 발생하면 웹 사이트 페이지가 로드될 때까지 사용자가 기다리는 시간이 길어진다. 또한 웹 사이트 서버에서 많은 수의 사용자를 처리하지 못해 서버의 작동이 중단될 수 있다. 라우팅은 네트워크가 정체 없이 최대한 많은 용량을 사용할 수 있도록 데이터 트래픽을 관리함으로써, 네트워크 장애를 최소화해 준다.

### 라우터란

라우터는 컴퓨팅 디바이스와 네트워크를 다른 네트워크에 연결하는 네트워킹 디바이스이다.

- 경로 결정
    - 라우터는 소스에서 대상으로 이동하는 데이터의 경로를 결정한다. 지연, 용량 및 속도와 같은 네트워크 지표를 분석하여 최상의 경로를 찾으려고 시도한다.
- 데이터 전달
    - 라우터는 선택한 경로의 다음 디바이스로 데이터를 전달하여 최종적으로 대상에 도달하도록 한다. 디바이스와 라우터는 동일한 네트워크에 있거나 서로 다른 네트워크에 있을 수 있다.
- 로드 밸런싱
    - 경우에 따라 라우터가 여러 경로를 사용하여 동일한 데이터 패킷의 여러 사본을 전송할 수도 있다. 이 방법을 통해 데이터 손실로 인한 오류를 줄이고 이중화를 구현하고 트래픽 볼륨을 관리한다.

### 라우팅 작동 원리

데이터는 데이터 패킷의 형태로 네트워크를 통해 이동한다. 각 데이터 패킷에는 패킷의 의도된 대상에 대한 정보가 포함된 헤더가 있다. 패킷이 대상으로 이동하는 동안 여러 라우터가 패킷을 여러 번 라우팅할 수 있다. 라우터는 수백만 개의 패킷에 대해 초당 수백만 번 이 프로세스를 수행한다.

데이터 패킷이 도착하면 라우터는 먼저 라우팅 테이블에서 그 주소를 찾는다. 그런 다음 라우터는 패킷을 네트워크의 다음 지점으로 전달하거나 이동한다.

### 라우팅 유형

- 정적 라우팅
    - 정적 라우팅에서는 네트워크 관리자가 정적 테이블을 사용하여 네트워크 경로를 수동으로 구성하고 선택한다. 정적 라우팅은 네트워크 설계나 파라미터가 일정하게 유지될 것으로 예상되는 경우에 유용하다.
    - 이 라우팅 기법에서는 정적 특성으로 인해 네트워크 정체와 같은 단점이 나타날 수 있다. 링크에서 장애가 발생할 경우에 대비해 관리자가 대체 경로를 구성할 수도 있지만, 일반적으로 정적 라우팅은 네트워크의 적응성과 유연성을 저하시켜 네트워크 성능을 제한한다.
- 동적 라우팅
    - 동적 라우팅에서 라우터는 실제 네트워크 조건에 따라 런타임에 라우팅 테이블을 만들고 업데이트한다. 동적 라우팅 테이블을 만들고 유지 관리하고 업데이트하는 규칙 집합인 동적 라우팅 프로토콜을 사용하여 소스에서 대상까지 가장 빠른 경로를 찾으려고 시도한다.
    - 동적 라우팅의 가장 큰 장점은 트래픽 볼륨, 대역폭, 네트워크 장애 등 변화하는 네트워크 조건에 대응한다는 것이다.

## 동적 라우팅 사용

- 동적 경로 세그먼트들을 “:”를 추가하는 것으로 Express 라우터 경로에 전달할 수 있다.
    - “:” 다음에 오는 이름은 req.params에서 데이터를 추출할 수 있는 이름이다.
    - 한 라우트에는 한 개 이상의 동적 세그먼트를 가질 수 있다.
    - 예시) url에서 ID 추출
        - 새로운 페이지를 표시하는 것이기 때문에 get 라우트를 사용한다.
        - 라우팅할 path를 ‘/products/:productId’라고 설정하면 뒤에 : productId는 동적 파라미터를 담게되어 req.params.productId로 접근이 가능하다.
            
            ```jsx
            router.get('/products:productId');
            // 콜론은 (:) express에게 productId와 같은 라우트를 탐색하지 말라는 신호를 보낸다.
            ```
            
- 선택적 (쿼리)매개변수들 : URL의 마지막에 물음표를 덧붙인 매개변수로 &를 통해 나누어 여러 개를 가질 수 있고 req.query.myParam을 통해 값을 추출할 수 있다.

## POST 요청으로 데이터 전달하기.

- POST: 요청 본문을 통해 데이터를 전달할 수 있다. ( GET에서는 불가능. )
    - 데이터 게시에만 가능하다. 데이터를 포스팅할 때 URL에 무언가 더 추가할 필요가 없다. 정보를 POST 본문에 넣으면 되기 때문이다. (데이터를 읽어올 때는 사용 불가. )
    
    ```jsx
    //add-detail.ejs
    <form action="/cart" method="post">
    	<button class="btn" type="submit">Add to Cart</button>
    	<input type="hidden" name="productId" value="<%= product.id %>">
    </form>
    //add to cart button이 있는 다른 모든 곳에 적용.
    ```
    
    ```jsx
    //router의 shop.js
    router.post('/cart', ShopController.postCart);
    ```
    
    ```jsx
    //controller의 shop.js
    exports const postCart = (req, res, next) => {
    	const prodId = req.body.productID;
    	console.log(prodID);
    	res.redirect('/cart/);
    };
    ```
    
- for문 또는 일반적인 조건문 안에 include가 포함되어 있는 경우 모든 product를 거쳐 실행하게 된다. 하지만 product는 해당 loop에서만 가능한 로컬변수이다.
    - 따라서 루프에 포함된 include에서 기본적으로 product를 받지 못한다.
    - 그러나 include에 입력하는 방법이 존재한다 include 함수에 객체를 입력하고 변수를 다시 추가해주는 두번째 인자를 추가하면 된다.
    
    ```jsx
    <%- include('../includes/add-to-cart.ejs', {product: product}) %>
    ```
    

## 쿼리 매개 변수 사용

- 기존의 상품을 편집하고 싶다면 전달해야 할 ID와 상품을 생성하는 대신 편집하고 싶다는 정보가 필요하다.
- url에 ?를 추가하여 모든 url에 추가할 수 있으며 edit=true를 비롯한 = 표시로 분할한 키 값 쌍을 넣어주면 된다.
- & 표시로 분할해 줌으로써 다수의 쿼리 매개 변수를 입력할 수도 있다. 이것을 부차적 데이터라고 한다.
- 도달하게 되는 라우터는 ? 표시까지를 통해 결정된다.
    
    ```jsx
    const editMode = req.query.edit;
    ```
    
- 컨트롤러에 존재하는 쿼리 매개변수를 확인하는 것이 가능하다.
    - editMode가 요청으로 이동하여 설정되고 쿼리객체가 있는가를 확인할 수 있다. 쿼리도 express.js에서 생성 및 관리를 함.
    - 또한 쿼리매개 변수에서 얻은 키에 접근을 시도하는 것만으로 데이터에 접근이 가능하다.
    - 값이 존재한다면 editMode는 true가 될 것이고, 존재하지 않는다면 false로 처리하게 된다.