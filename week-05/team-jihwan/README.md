# TEAM 지환 - 5주차 RBF

## 라우팅이란 ?

- URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드 포인트에 대한 클라이언트 요청에 대한 응답을 말한다.
    - 엔드포인트 : API가 서버에서 리소스에 접근할 수 있도록 가능하게 하는 URL
- 네트워크에서 경로를 선택하는 프로세스이다.
- 미리 정해진 규칙을 사용하여 최상의 경로를 선택해낸다.

### 라우팅이 중요한 이유

라우팅은 네트워크 통신의 효율성을 높인다. 네트워크 통신 장애가 발생하면 웹 사이트 페이지가 로드될 때까지 사용자가 기다리는 시간이 길어진다. 또한 웹 사이트 서버에서 많은 수의 사용자를 처리하지 못해 서버의 작동이 중단될 수 있다. 라우팅은 네트워크가 정체 없이 최대한 많은 용량을 사용할 수 있도록 데이터 트래픽을 관리함으로써, 네트워크 장애를 최소화해 준다.

## 라우터란 ?

- 라우터는 디바이스와 네트워크를 다른 네트워크에 연결하는 네트워킹 디바이스다.
- 기본 기능
    - 경로 설정 : 소스에서 대상으로 이동하는 데이터의 경로를 설정한다. 최상의 경로를 찾으려고 시도한다.
    - 데이터 전달 : 선택한 경로의 다음 디바이스로 데이터를 전달하여 최종적으로 대상에 도달하도록 한다.
    - 로드 밸런싱 : 여러 경로를 사용하는 경우, 동일한 데이터 패킷을 나눠서 전송할 수도 있다. (데이터 손실로 인한 오류를 줄일 수 있다.)

## 라우팅 유형

- 정적 라우팅 : 네트워크 관리자가 정적 테이블을 사용하여 네트워크 경로를 수동으로 구성하고 선택 .
    - 장점 : 네트워크 설계나 파라미터가 일정하게 유지될 경우 유용하다.
    - 단점 : 네트워크의 적응성과 유연성을 저하시켜 네트워크 성능을 제한한다.
- 동적 라우팅 : 테이블을 만들고 유지하고 관리하고 업데이트 하는 규칙집합인 동적 라우팅 프로토콜을 사용해서 소스에서 대상까지 가장 빠른 경로를 찾으려고 시도한다.
    - 장점: 네트워크 장애, 트래픽 볼륨 등 변화하는 네티워크 조건에 대응할 수 있다.
    - 단점 : 대역폭 소비가 높고 오버헤드가 증가한다.

### 라우팅 작동 원리

데이터는 데이터 패킷의 형태로 네트워크를 통해 이동한다. 각 데이터 패킷에는 패킷의 의도된 대상에 대한 정보가 포함된 헤더가 있다. 패킷이 대상으로 이동하는 동안 여러 라우터가 패킷을 여러 번 라우팅할 수 있다. 라우터는 수백만 개의 패킷에 대해 초당 수백만 번 이 프로세스를 수행한다.

데이터 패킷이 도착하면 라우터는 먼저 라우팅 테이블에서 그 주소를 찾는다. 그런 다음 라우터는 패킷을 네트워크의 다음 지점으로 전달하거나 이동한다.

## 동적 라우팅 사용

- 동적 경로 세그먼트들을 “:”를 추가하는 것으로 Express 라우터 경로에 전달할 수 있다.
    - “:” 다음에 오는 이름은 req.params에서 데이터를 추출할 수 있는 이름이다.
    - 한 라우트에는 한 개 이상의 동적 세그먼트를 가질 수 있다.
    - 예시) url에서 ID 추출
        - 새로운 페이지를 표시하는 것이기 때문에 get 라우트를 사용한다.
        - 라우팅할 path를 ‘/products/:productId’라고 설정하면 뒤에 : productId는 동적 파라미터를 담게되어 req.params.productId로 접근이 가능하다.
            
            ```jsx
            router.get('/products:productId');
            // 콜론은 (:) express에게 productId와 같은 라우트를 탐색하지 말라는 신호를 보낸다.
            ```
            
- 선택적 (쿼리)매개변수들 : URL의 마지막에 물음표를 덧붙인 매개변수로 &를 통해 나누어 여러 개를 가질 수 있고 req.query.myParam을 통해 값을 추출할 수 있다.

## POST 요청으로 데이터 전달하기.

- POST: 요청 본문을 통해 데이터를 전달할 수 있다. (GET에서도 가능은 하지만 지원하는 곳이 많이 없어서 사실상 사용하지 않는다)
    - 데이터 게시에만 가능하다. 데이터를 포스팅할 때 URL에 무언가 더 추가할 필요가 없다. 정보를 POST 본문에 넣으면 되기 때문이다. (데이터를 읽어올 때는 사용 불가. )
    
    ```jsx
    //add-detail.ejs
    <form action="/cart" method="post">
    	<button class="btn" type="submit">Add to Cart</button>
    	<input type="hidden" name="productId" value="<%= product.id %>">
    </form>
    //add to cart button이 있는 다른 모든 곳에 적용.
    ```
    
    ```jsx
    //router의 shop.js
    router.post('/cart', ShopController.postCart);
    ```
    
    ```jsx
    //controller의 shop.js
    exports const postCart = (req, res, next) => {
    	const prodId = req.body.productID;
    	console.log(prodID);
    	res.redirect('/cart/);
    };
    ```
    
- for문 또는 일반적인 조건문 안에 include가 포함되어 있는 경우 모든 product를 거쳐 실행하게 된다. 하지만 product는 해당 loop에서만 가능한 로컬변수이다.
    - 따라서 루프에 포함된 include에서 기본적으로 product를 받지 못한다.
    - 그러나 include에 입력하는 방법이 존재한다 include 함수에 객체를 입력하고 변수를 다시 추가해주는 두번째 인자를 추가하면 된다.
    
    ```jsx
    <%- include('../includes/add-to-cart.ejs', {product: product}) %>
    ```
    

## 쿼리 매개 변수 사용

- 기존의 상품을 편집하고 싶다면 전달해야 할 ID와 상품을 생성하는 대신 편집하고 싶다는 정보가 필요하다.
- url에 ?를 추가하여 모든 url에 추가할 수 있으며 edit=true를 비롯한 = 표시로 분할한 키 값 쌍을 넣어주면 된다.
- & 표시로 분할해 줌으로써 다수의 쿼리 매개 변수를 입력할 수도 있다. 이것을 부차적 데이터라고 한다.
- 쿼리 스트링 사용시 리스트 타입이나 Object와 같은 중첩 타입 또한 사용가능하다.
    - 리스트 타입
    ```jsx
    id = ['a','b'] //일경우
    id = a & id = b
    ```
    - 중첩 타입
    ```jsx
    a : {b: "c"} //일 경우 
    ?a[b]=c 
    ```
- 도달하게 되는 라우터는 ? 표시까지를 통해 결정된다.
    
    ```jsx
    const editMode = req.query.edit;
    ```
    
- 컨트롤러에 존재하는 쿼리 매개변수를 확인하는 것이 가능하다.
    - editMode가 요청으로 이동하여 설정되고 쿼리객체가 있는가를 확인할 수 있다. 쿼리도 express.js에서 생성 및 관리를 함.
    - 또한 쿼리매개 변수에서 얻은 키에 접근을 시도하는 것만으로 데이터에 접근이 가능하다.
    - 값이 존재한다면 editMode는 true가 될 것이고, 존재하지 않는다면 false로 처리하게 된다.